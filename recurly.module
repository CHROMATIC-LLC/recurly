<?php

/**
 * @file
 * Recurly.
 *
 * Uses Recurly's PHP client library to interact with their API and integrate it
 * with Drupal user accounts.
 */

use Drupal\Component\Utility\SafeMarkup;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Link;
use Drupal\Core\Url;

/**
 * Implements hook_help().
 */
function recurly_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'recurly.subscription_plans_overview':
      return '<p>' . t('Plans should be defined and updated at Recurly.com itself. The order and enabled state of a plan will affect the built-in signup pages.') . '</p>';
  }
}

/**
 * Implements hook_theme().
 */
function recurly_theme() {
  $items['recurly_subscription_summary'] = [
    'variables' => [
      'plan_code' => NULL,
      'plan_name' => NULL,
      'state_array' => NULL,
      'state_status' => NULL,
      'period_end_header' => NULL,
      'cost' => NULL,
      'quantity' => NULL,
      'add_ons' => [],
      'start_date' => NULL,
      'end_date' => NULL,
      'current_period_start' => NULL,
      'current_period_ends_at' => NULL,
      'total' => NULL,
      'subscription_links' => [],
      'message' => NULL,
      'subscription' => NULL,
      'account' => NULL,
    ],
    'template' => 'recurly-subscription-summary',
  ];
  $items['recurly_credit_card_information'] = [
    'variables' => [
      'first_name' => NULL,
      'last_name' => NULL,
      'card_type' => NULL,
      'exp_date' => NULL,
      'last_four' => NULL,
      'card_num_masked' => NULL,
    ],
    'template' => 'recurly-credit-card-information',
  ];
  $items['recurly_invoice'] = [
    'variables' => [
      'invoice' => NULL,
      'invoice_account' => NULL,
      'entity_type' => NULL,
      'entity' => NULL,
      'error_message' => NULL,
    ],
    'template' => 'recurly-invoice',
  ];
  $items['recurly_invoice_list'] = [
    'variables' => [
      'invoices' => NULL,
      'entity_type' => NULL,
      'entity' => NULL,
      'per_page' => NULL,
      'total' => NULL,
    ],
    'template' => 'recurly-invoice-list',
  ];
  $items['recurly_subscription_plan_select'] = [
    'variables' => [
      'plans' => NULL,
      'entity_type' => NULL,
      'entity' => NULL,
      'currency' => NULL,
      'mode' => 'signup',
      'subscriptions' => NULL,
      'subscription_id' => NULL,
    ],
    'template' => 'recurly-subscription-plan-select',
    // The $mode of "change" or "signup" may be appended to the template name.
    'pattern' => 'recurly_subscription_plan_select__',
  ];
  $items['recurly_subscription_cancel_confirm'] = [
    'render element' => 'form',
    'template' => 'recurly-subscription-cancel-confirm',
  ];

  return $items;
}

/**
 * Implements hook_libraries_info().
 */
function recurly_libraries_info() {
  $libraries['recurly'] = [
    'name' => 'Recurly',
    'vendor url' => 'https://github.com/recurly/recurly-client-php',
    'download url' => 'https://github.com/recurly/recurly-client-php/releases/latest',
    'path' => 'lib',
    'version' => '2.*',
    'files' => [
      'php' => ['recurly.php'],
    ],
  ];
  return $libraries;
}

/**
 * Implements hook_entity_update().
 *
 * Update the Recurly remote account when the local Drupal entity is updated.
 */
function recurly_entity_update(\Drupal\Core\Entity\EntityInterface $entity) {
  $entity_type = $entity->getEntityType()->getLowercaseLabel();
  // If this isn't the enabled Recurly entity type, do nothing.
  if (\Drupal::config('recurly.settings')->get('recurly_entity_type') !== $entity_type) {
    return;
  }

  // Check if this entity has a remote Recurly account that we should sync.
  $local_account = recurly_account_load(['entity_type' => $entity_type, 'entity_id' => $entity->id()], TRUE);
  if (!$local_account) {
    return;
  }

  // Check if any of the mapping tokens have changed.
  $original_entity = \Drupal::entityManager()->getStorage($entity_type)->load($entity->getOriginalId());
  $original_values = [];
  $updated_values = [];

  $recurly_token_manager = \Drupal::service('recurly.token_manager');
  foreach ($recurly_token_manager->tokenMapping() as $recurly_field => $token) {
    $original_values[$recurly_field] = \Drupal::token()->replace($token, [$entity_type => $original_entity], ['clear' => TRUE, 'sanitize' => FALSE]);
    $updated_values[$recurly_field] = \Drupal::token()->replace($token, [$entity_type => $entity], ['clear' => TRUE, 'sanitize' => FALSE]);
  }
  $original_values['username'] = $original_entity->label();
  $updated_values['username'] = $entity->label();

  // If there are any changes, push them to Recurly.
  if ($original_values !== $updated_values) {
    try {
      $recurly_account = recurly_account_load(['entity_type' => $entity_type, 'entity_id' => $entity->id()]);
      $address_fields = [
        'address1',
        'address2',
        'city',
        'state',
        'zip',
        'country',
        'phone',
      ];
      foreach ($updated_values as $field => $value) {
        if (strlen($value)) {
          if (in_array($field, $address_fields)) {
            // The Recurly PHP client doesn't check for nested objects when
            // determining what properties have changed when updating an object.
            // This works around it by re-assigning the address property instead
            // of directly modifying the address's fields. This can be removed
            // when https://github.com/recurly/recurly-client-php/pull/80 is
            // merged in.
            //
            // $recurly_account->address->{$field} = $value;
            $adr = $recurly_account->address;
            $adr->{$field} = $value;
            $recurly_account->address = $adr;
          }
          else {
            $recurly_account->{$field} = $value;
          }
        }
      }
      $recurly_account->update();
    }
    catch (Recurly_Error $e) {
      drupal_set_message(t('The billing system reported an error: "@error" To ensure proper billing, please correct the problem if possible or contact support.', ['@error' => $e->getMessage()]), 'warning');
      \Drupal::logger('recurly')->error('Account information could not be sent to the Recurly, it reported "@error" while trying to update !title with the values @values.', [
        '@error' => $e->getMessage(),
        '!title' => \Drupal::l($entity->label(), $entity->toUrl()),
        '@values' => print_r($updated_values, 1),
      ]);
    }
  }
}

/**
 * Implements hook_user_cancel().
 *
 * Cancel a Recurly account when the user account is canceled. It's important to
 * note this hook is *not* called if the user account is just being straight-up
 * deleted, which is fine because hook_entity_delete() will be called for that
 * situation.
 */
function recurly_user_cancel($edit, $account, $method) {
  $entity_type = \Drupal::config('recurly.settings')->get('recurly_entity_type');
  if ($entity_type === 'user') {
    // Check for a local account first, no need to attempt to close an account
    // if we don't have any information about it.
    $local_account = recurly_account_load(['entity_type' => $entity_type, 'entity_id' => $account->id()], TRUE);
    if ($local_account) {
      $recurly_account = recurly_account_load(['entity_type' => $entity_type, 'entity_id' => $account->id()]);
      recurly_account_close($recurly_account);
    }
  }
}

/**
 * Implements hook_entity_delete().
 *
 * This hook is *not* called when a user cancels their account through any
 * mechanism other than "delete account". This fires when user accounts are
 * being deleted, or when subscriptions are on other entities, such as nodes.
 */
function recurly_entity_delete(\Drupal\Core\Entity\EntityInterface $entity) {
  if (($entity_type = $entity->getEntityType()->getLowercaseLabel()) == \Drupal::config('recurly.settings')->get('recurly_entity_type')) {
    // Check for a local account first, no need to attempt to close an account
    // if we don't have any information about it.
    $local_account = recurly_account_load(['entity_type' => $entity_type, 'entity_id' => $entity->id()], TRUE);
    if ($local_account) {
      $recurly_account = recurly_account_load(['entity_type' => $entity_type, 'entity_id' => $entity->id()]);
      recurly_account_delete($recurly_account);
    }
  }
}

/**
 * Initializes the Recurly API client with a given set of account settings.
 *
 * @param array $settings
 *   An array of Recurly account settings including the following keys or NULL
 *   to use the site-wide account settings.
 *   - username: the API username to use
 *   - password: the API password for the given username
 *   - subdomain: the subdomain configured for your Recurly account.
 *   - environment: the current environment of the given account, either
 *     'sandbox' or 'production'.
 *
 * @return bool
 *   TRUE or FALSE indicating whether or not the client was initialized with the
 *   specified account settings.
 */
function recurly_client_initialize($settings = NULL, $reset = FALSE) {
  static $initialized = FALSE;
  $client = NULL;

  // Skip the process if we're not setting up a new connection and we're already
  // set up with a configuration.
  if ($initialized && !$reset) {
    return TRUE;
  }

  // If no settings array was given, use the default account settings.
  if (empty($settings)) {
    $settings = [
      'api_key' => \Drupal::config('recurly.settings')->get('recurly_private_api_key'),
      'subdomain' => \Drupal::config('recurly.settings')->get('recurly_subdomain'),
      'public_key' => \Drupal::config('recurly.settings')->get('recurly_public_key'),
    ];
  }

  // If we can find a path in the libraries directory to the Recurly PHP client
  // library...
  $path = libraries_get_path('recurly');
  if ($path && file_exists($path . '/lib/recurly.php')) {
    // Include the library files and configure authentication.
    require_once $path . '/lib/recurly.php';

    // Required for the API.
    Recurly_Client::$apiKey = $settings['api_key'];
  }
  else {
    \Drupal::logger('recurly')->error('Could not find the Recurly PHP client library in sites/all/libraries/recurly.', []);
    return FALSE;
  }

  $initialized = TRUE;
  return TRUE;
}

/**
 * Loads a Recurly account record based on the given conditions.
 *
 * @param array $conditions
 *   An associative array of values to look for in the conditions of the query;
 *   normally used to look-up on account_code or uid.
 * @param bool $local
 *   Boolean indicating whether or not to only return local data; defaults to
 *   FALSE, meaning it will attempt to load the full linked account object.
 *
 * @return object
 *   The fully loaded account object from Recurly if possible. If Recurly cannot
 *   be accessed, just returns an object representing the data stored locally.
 *   If the account no longer exists at Recurly, the returned object will
 *   include an additional 'orphaned' property set to TRUE. Returns FALSE if no
 *   data can be found locally at all.
 */
function recurly_account_load($conditions = [], $local = FALSE) {
  // Create a base select query object.
  $query = db_select('recurly_account', 'ra')->fields('ra');

  // Add conditions to it based on the passed array.
  foreach ($conditions as $key => $value) {
    $query->condition($key, $value);
  }

  // Retrieve data if available.
  $data = $query->execute()->fetchObject();

  // Bail now if no data was returned.
  if (empty($data)) {
    return FALSE;
  }

  // If we only want local data, return it now.
  if ($local) {
    return $data;
  }

  // Attempt to load the full account from Recurly.
  try {
    recurly_client_initialize();
    try {
      $recurly_account = Recurly_Account::get($data->account_code);
    }
    catch (Recurly_NotFoundError $e) {
      // Return the orphaned data if no account was found at Recurly.
      $data->orphaned = TRUE;
      return $data;
    }

    // If any data has changed remotely, update it locally now.
    if ($recurly_account->state != $data->status) {
      recurly_account_save($recurly_account, $data->entity_type, $data->entity_id);
    }
  }
  catch (Exception $e) {
    return $data;
  }

  return $recurly_account;
}

/**
 * Saves an account record.
 *
 * Optionally exporting the saved data to Recurly as a new account or update
 * request as necessary.
 *
 * @param object $recurly_account
 *   The Recurly account object to save.
 * @param string $entity_type
 *   The entity type with which this account is associated.
 * @param int $entity_id
 *   The ID of the entity with which this account is associated.
 * @param bool $export
 *   Boolean indicating whether or not the saved account information should also
 *   be exported to Recurly by either creating a new account or updating an
 *   existing account based on the saved values using the Recurly API.
 *
 * @return mixed
 *   FALSE on failure of either the local save or optional export or
 *   STATUS_INSERT or STATUS_UPDATE indicating the type of query performed to
 *   save the account information locally.
 */
function recurly_account_save($recurly_account, $entity_type, $entity_id, $export = FALSE) {
  // First attempt to save the data at Recurly if specified. Failing an export
  // will prevent local data from being saved so you don't end up with a local
  // record that does not match a record at Recurly.
  if ($export) {
    // Check to see if the record already exists.
    try {
      $remote_account = Recurly_Account::get($recurly_account->account_code);
      // If it does than update the account now.
      try {
        $recurly_account->update();
      }
      catch (Recurly_NotFoundError $e) {
        watchdog_exception('recurly', $e);
        return FALSE;
      }
    }
    catch (Exception $e) {
      // Try and create the new account at Recurly now.
      try {
        $recurly_account->create();
      }
      catch (Recurly_NotFoundError $e) {
        watchdog_exception('recurly', $e);
        return FALSE;
      }
    }
  }

  // Generate an array of data to save.
  $fields = [
    'entity_type' => $entity_type,
    'entity_id' => $entity_id,
    'updated' => REQUEST_TIME,
  ];

  // Add the status based on whatever data we have available.
  if (!empty($recurly_account->state)) {
    $fields['status'] = $recurly_account->state;
  }
  elseif (!empty($recurly_account->status)) {
    $fields['status'] = $recurly_account->status;
  }
  else {
    $fields['status'] = 'active';
  }

  // Execute a merge query that will either insert a new record or update an
  // existing record accordingly.
  return db_merge('recurly_account')
    ->key(['account_code' => $recurly_account->account_code])
    ->fields($fields)
    ->execute();
}

/**
 * Cancel a remote Recurly account.
 */
function recurly_account_close($recurly_account, $cancelation_method = NULL) {
  if (empty($cancelation_method)) {
    $cancelation_method = \Drupal::config('recurly.settings')->get('recurly_subscription_cancel_behavior');
  }

  if (empty($recurly_account->orphaned)) {
    try {
      // By default, closing an account will cancel all the subscriptions in
      // that account. If refunding accounts upon cancelation, we must manually
      // terminate each active subscription.
      if ($cancelation_method !== 'cancel') {
        $subscription_list = Recurly_SubscriptionList::getForAccount($recurly_account->account_code);
        foreach ($subscription_list as $subscription) {
          if ($subscription->state === 'active') {
            $username = $recurly_account->username ? $recurly_account->username : $recurly_account->account_code;
            if ($cancelation_method === 'terminate_prorated') {
              drupal_set_message(t('Prorated refund for @plan refunded to @username.', ['@plan' => $subscription->plan->name, '@username' => $username]));
              $subscription->terminateAndPartialRefund();
            }
            else {
              drupal_set_message(t('Full refund for @plan refunded to @username.', ['@plan' => $subscription->plan->name, '@username' => $username]));
              $subscription->terminateAndRefund();
            }
          }
        }
      }
      // Then close the account.
      $recurly_account->close();
    }
    catch (Recurly_Error $e) {
      // Throw the highest level alert. Failure could result in accounts getting
      // charged after the Drupal account is deleted.
      \Drupal::logger('recurly')->alert('A Recurly account with the account code @code was intended to be closed, but may still open! The Recurly API returned the error "@error".', [
        '@code' => $recurly_account->account_code,
        '@error' => $e->getMessage(),
      ]);
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Delete a Recurly database record and the account on Recurly.com.
 */
function recurly_account_delete($recurly_account, $cancelation_method = NULL) {
  recurly_account_close($recurly_account, $cancelation_method);
  db_delete('recurly_account')
    ->condition('account_code', $recurly_account->account_code)
    ->execute();
}

/**
 * Check if an account has any active subscriptions.
 *
 * @return bool
 *   TRUE if the user has an active subscription, or FALSE if no
 *   active subscriptions are located.
 */
function recurly_account_has_active_subscriptions($account_code) {
  return count(recurly_account_get_subscriptions($account_code, 'active')) > 0 ? TRUE : FALSE;
}

/**
 * Get a list of active subscriptions for a particular account code.
 */
function recurly_account_get_subscriptions($account_code, $state) {
  static $accounts;

  if (!isset($accounts[$account_code])) {
    $accounts[$account_code] = [];

    recurly_client_initialize();
    $subscription_list = Recurly_SubscriptionList::getForAccount($account_code, ['per_page' => 200]);
    $accounts[$account_code] = ['active' => [], 'expired' => []];
    foreach ($subscription_list as $subscription) {
      if ($subscription->state !== 'expired') {
        $accounts[$account_code]['active'][$subscription->uuid] = $subscription;
      }
      else {
        $accounts[$account_code]['expired'][$subscription->uuid] = $subscription;
      }
    }
  }

  if ($state === 'active') {
    return $accounts[$account_code]['active'];
  }
  elseif ($state === 'expired') {
    return $accounts[$account_code]['expired'];
  }

  // Otherwise return all subscriptions.
  return $accounts[$account_code] + $accounts[$account_code];
}

/**
 * Returns an array of subscription plan objects for the current account.
 *
 * Retrieves them from a local cache if possible.
 *
 * @param bool $reset_cache
 *   Boolean indicating whether or not to reset the subscription plan cache when
 *   retrieving plans.
 *
 * @return array
 *   An array of subscription plan objects.
 */
function recurly_subscription_plans($reset_cache = FALSE) {
  static $plans;

  // If we haven't specified a cache reset, attempt to retrieve plans from the
  // cache before getting them from Recurly.
  if (!$reset_cache && isset($plans)) {
    return $plans;
  }

  // Initialize the Recurly client with the site-wide settings.
  if (!recurly_client_initialize()) {
    return FALSE;
  }

  // Retrieve the subscription plans from Recurly.
  $plans = Recurly_PlanList::get();

  return $plans;
}

/**
 * Returns an edit URL for a subscription plan.
 *
 * @param object $plan
 *   The subscription plan object returned by the Recurly client.
 *
 * @return string
 *   The URL for the plan's edit page at Recurly.
 */
function recurly_subscription_plan_edit_url($plan) {
  $recurly_url_manager = \Drupal::service('recurly.url_manager');
  return $recurly_url_manager->hostedUrl('company/plans/' . $plan->plan_code);
}

/**
 * Determine if a Recurly subscription object is currently in a trial.
 */
function recurly_subscription_in_trial($subscription) {
  if ($subscription->trial_started_at && $subscription->trial_ends_at) {
    $subscription->trial_started_at->setTimezone(new DateTimeZone('UTC'));
    $subscription->trial_ends_at->setTimezone(new DateTimeZone('UTC'));
    $start = $subscription->trial_started_at->format('U');
    $end = $subscription->trial_ends_at->format('U');
    if (REQUEST_TIME > $start && REQUEST_TIME < $end) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Return a URL for a specified operation.
 *
 * This function should be used when generating links to operations that may
 * have variable locations, such as updating billing information or changing
 * plan levels.
 *
 * @param string $operation
 *   May be one of the following operations:
 *    - select_plan ($context contains account_code or entity_type/entity_id)
 *    - change_plan
 *    - cancel
 *    - update_billing ($context contains account_code)
 *    - subscribe ($context contains plan_code)
 *    - reactivate ($context contains account_code or entity_type/entity_id)
 * @param array $context
 *   An array of contextual information needed for generating the link.
 *
 * @return \Drupal\Core\Url
 *   A Drupal Url object containing a route and route parameters, or NULL if no
 *   module is available to handle the operation.
 */
function recurly_url($operation, $context) {
  $urls = \Drupal::moduleHandler()->invokeAll('recurly_url_info', [$operation, $context]);

  $return_url = NULL;
  foreach ($urls as $url) {
    if ($url) {
      $return_url = $url;
    }
  }
  return $return_url;
}

/**
 * Implements hook_recurly_url_info().
 */
function recurly_recurly_url_info($operation, $context) {
  // Only provide URLs for built-in page types.
  $recurly_entity_type = \Drupal::config('recurly.settings')->get('recurly_entity_type');
  if (empty($recurly_entity_type) || $recurly_entity_type !== $context['entity_type']) {
    return;
  }

  switch ($operation) {
    case 'select_plan':
      return Url::fromRoute('recurly.subscription_signup', ['entity' => $context['entity']->id()]);

    case 'change_plan':
      return Url::fromRoute('recurly.subscription_plan_change', [
        'entity' => $context['entity']->id(),
        'subscription_id' => $context['subscription']->uuid,
        'new_plan_code' => isset($context['plan_code']) ? $context['plan_code'] : NULL,
      ]);

    case 'cancel':
      return Url::fromRoute('recurly.subscription_cancel', [
        'entity' => $context['entity']->id(),
        'subscription_id' => $context['subscription']->uuid,
      ]);

    case 'reactivate':
      return Url::fromRoute('recurly.subscription_reactivate', [
        'entity' => $context['entity']->id(),
        'subscription_id' => $context['subscription']->uuid,
      ]);

    case 'redeem_coupon':
      return Url::fromRoute('recurly.redeem_coupon', ['entity' => $context['entity']->id()]);
  }
}

/**
 * Provide a list of currencies supported by Recurly.
 */
function recurly_currency_list() {
  $currencies = [
    'USD' => ['$', ' USD'],
    'AUD' => ['$', ' AUD'],
    'CAD' => ['$', ' CAD'],
    'EUR' => ['', ' €', ' ', ','],
    'GBP' => ['£', ''],
    'CZK' => ['', ' Kč', ' ', ','],
    'DKK' => ['', ' kr.', ' ', ','],
    'HUF' => ['', ' Ft', NULL, NULL, 0],
    'JPY' => ['¥', ''],
    'NOK' => ['', ' Nkr', ' ', ','],
    'NZD' => ['NZ$', ''],
    'PLN' => ['', ' zł', ' ', ','],
    'SGD' => ['S$', ''],
    'SEK' => ['', ' kr', ' ', ','],
    'CHF' => ['', ' Fr.', NULL, NULL, NULL, '0.05'],
    'ZAR' => ['R', ''],
  ];
  return $currencies;
}

/**
 * Calculate a prorated refund amount.
 */
function recurly_subscription_calculate_refund($subscription, $type = 'prorated') {
  if ($type == 'none' || recurly_subscription_in_trial($subscription)) {
    return 0;
  }

  $subscription->current_period_started_at->setTimezone(new DateTimeZone('UTC'));
  $subscription->current_period_ends_at->setTimezone(new DateTimeZone('UTC'));
  $start = $subscription->current_period_started_at->format('U');
  $end = $subscription->current_period_ends_at->format('U');
  $total_period_time = $end - $start;
  $remaining_time = $end - REQUEST_TIME;

  // Past due subscriptions get no refund.
  if ($remaining_time < 0) {
    return 0;
  }
  if ($type == 'full') {
    return $subscription->unit_amount_in_cents;
  }
  elseif ($type === 'prorated') {
    return $subscription->unit_amount_in_cents * $remaining_time / $total_period_time;
  }
}

/**
 * Format a date for use in invoices.
 */
function recurly_format_date($date) {
  $format = \Drupal::config('recurly.settings')->get('recurly_date_format');
  if (is_object($date)) {
    $date->setTimezone(new DateTimeZone('UTC'));
    $timestamp = $date->format('U');
  }
  else {
    $timestamp = strtotime($date);
  }

  return is_numeric($timestamp) ? format_date($timestamp, $format) : NULL;
}

/**
 * Format a Recurly subscription state.
 */
function recurly_format_state($state) {
  switch ($state) {
    case 'active':
      return t('Active');

    case 'canceled':
      return t('Canceled (will not renew)');

    case 'expired':
      return t('Expired');

    case 'future':
      return t('Future Activation');

    case 'pending_subscription':
      return t('Switching to new plan');

    case 'in_trial':
      return t('Trial');

    case 'live':
      return t('Live');

    case 'past_due':
      return t('Past Due');
  }
}

/**
 * Format a price for display.
 */
function recurly_format_currency($price_in_cents, $currency, $html = FALSE) {
  $currencies = recurly_currency_list();
  $currency_info = isset($currencies[$currency]) ? $currencies[$currency] : ['', ' ' . $currency];
  $prefix = $currency_info[0] ? $currency_info[0] : '';
  $suffix = $currency_info[1] ? $currency_info[1] : '';
  $thousands_separator = isset($currency_info[2]) ? $currency_info[2] : ',';
  $decimal_separator = isset($currency_info[3]) ? $currency_info[3] : '.';
  $decimals = isset($currency_info[4]) ? $currency_info[4] : 2;
  $rounding_step = isset($currency_info[5]) ? $currency_info[5] : NULL;

  // Commerce module provides a more flexible and complete currency formatter.
  if (\Drupal::moduleHandler()->moduleExists('commerce')) {
    $formatted = commerce_currency_format($price_in_cents, $currency, NULL, TRUE);
  }
  else {
    // Convert to a decimal amount.
    $float = $price_in_cents / 100;

    // Round the amount if necessary i.e. Francs round up to the nearest 0.05.
    if ($rounding_step) {
      $modifier = 1 / $rounding_step;
      $float = round($float * $modifier) / $modifier;
    }

    // Format the number.
    $formatted = $prefix . number_format($float, $decimals, $decimal_separator, $thousands_separator) . $suffix;
  }

  // Wrap each part in HTML if requested.
  if ($html) {
    $amount_string = '';
    $amount_array = [];
    preg_match('/([^0-9]*)?([0-9' . preg_quote($thousands_separator) . ']+)([0-9' . preg_quote($decimal_separator) . ']+)(.*)?/', $formatted, $amount_array);
    if ($amount_array[1]) {
      $amount_string .= '<span class="currency-prefix">' . $amount_array[1] . '</span>';
    }
    if ($amount_array[2]) {
      $amount_string .= '<span class="currency-dollars">' . $amount_array[2] . '</span>';
    }
    if ($amount_array[3]) {
      $amount_string .= '<span class="currency-cents">' . $amount_array[3] . '</span>';
    }
    if ($amount_array[4]) {
      $amount_string .= '<span class="currency-suffix">' . $amount_array[4] . '</span>';
    }
    $formatted = $amount_string;
  }

  return $formatted;
}

/**
 * Format an interval of time in a human-readable way.
 */
function recurly_format_price_interval($amount, $count, $unit, $html = FALSE) {
  if ($amount === NULL) {
    if ($unit == 'days') {
      return \Drupal::translation()->formatPlural($count, '1 day trial', '@count day trial');
    }
    else {
      return \Drupal::translation()->formatPlural($count, '1 month trial', '@count month trial');
    }
  }

  $replacements = [
    '!count' => $html ? '<span class="plan-count">' . SafeMarkup::checkPlain($count) . '<span>' : SafeMarkup::checkPlain($count),
    '!amount' => $html ? '<span class="plan-amount">' . $amount . '</span>' : $amount,
  ];
  if ($count == 1) {
    switch ($unit) {
      case 'days':
        return t('!amount per day', $replacements);

      case 'months':
        return t('!amount per month', $replacements);
    }
  }
  elseif ($count == 7 && $unit == 'days') {
    return t('!amount per week', $replacements);
  }
  elseif ($count == 12 && $unit == 'months') {
    return t('!amount per year', $replacements);
  }
  else {
    switch ($unit) {
      case 'days':
        return t('!amount every !count days', $replacements);

      case 'months':
        return t('!amount every !count months', $replacements);
    }
  }
}

/**
 * Simple function to print out human-readable transaction status.
 */
function recurly_format_transaction_status($status) {
  switch ($status) {
    case 'success':
      return t('Successful payment');

    case 'failed':
      return t('Failed payment');

    case 'voided':
      return t('Voided');

    case 'declined':
      return t('Card declined');

    default:
      return SafeMarkup::checkPlain($status);
  }
}

/**
 * Format a Recurly coupon in a human-readable string.
 *
 * @param \Recurly_Coupon $coupon
 *   The Recurly coupon object being formatted for display.
 * @param string $currency
 *   The currency code in which the coupon is being redeemed.
 * @param bool $html
 *   Whether to return the formatted string with wrapping HTML or not.
 *
 * @return string
 *   The formatted string ready for printing.
 */
function recurly_format_coupon(\Recurly_Coupon $coupon, $currency, $html = FALSE) {
  if ($coupon->discount_type === 'percent') {
    $amount = SafeMarkup::checkPlain($coupon->discount_percent) . '%';
  }
  else {
    $coupon_currency = $coupon->discount_in_cents[$currency];
    $amount = recurly_format_currency($coupon_currency->amount_in_cents, $currency, $html);
  }

  return SafeMarkup::checkPlain($coupon->name) . ' (' . t('@amount discount', ['@amount' => $amount]) . ')';
}

/**
 * Implements hook_preprocess_recurly_subscription_plan_select().
 *
 * Shared preprocess function for the presentation of the signup & change page.
 */
function template_preprocess_recurly_subscription_plan_select(&$variables) {
  $plans = $variables['plans'];
  $currency = $variables['currency'];
  $entity_type = $variables['entity_type'];
  $entity = $variables['entity'];
  $subscriptions = $variables['subscriptions'];
  $subscription_id = $variables['subscription_id'];

  $current_subscription = NULL;
  foreach ($subscriptions as $subscription) {
    if ($subscription->uuid === $subscription_id) {
      $current_subscription = $subscription;
      break;
    }
  }

  // If currency is undefined, use the subscription currency.
  if ($current_subscription && empty($currency)) {
    $currency = $current_subscription->currency;
    $variables['currency'] = $currency;
  }

  // Prepare an easy to loop-through list of subscriptions.
  $variables['filtered_plans'] = [];
  foreach ($plans as $plan_code => $plan) {
    $setup_fee_amount = NULL;
    foreach ($plan->setup_fee_in_cents as $setup_currency) {
      if ($setup_currency->currencyCode === $currency) {
        $setup_fee_amount = recurly_format_currency($setup_currency->amount_in_cents, $setup_currency->currencyCode, TRUE);
        break;
      }
    }
    $unit_amount = NULL;
    foreach ($plan->unit_amount_in_cents as $unit_currency) {
      if ($unit_currency->currencyCode === $currency) {
        $unit_amount = recurly_format_currency($unit_currency->amount_in_cents, $unit_currency->currencyCode, TRUE);
        break;
      }
    }
    $variables['filtered_plans'][$plan_code] = [
      'plan_code' => SafeMarkup::checkPlain($plan_code),
      'name' => SafeMarkup::checkPlain($plan->name),
      'description' => SafeMarkup::checkPlain($plan->description),
      'setup_fee' => $setup_fee_amount,
      'amount' => $unit_amount,
      'plan_interval' => recurly_format_price_interval($unit_amount, $plan->plan_interval_length, $plan->plan_interval_unit, TRUE),
      'trial_interval' => $plan->trial_interval_length ? recurly_format_price_interval(NULL, $plan->trial_interval_length, $plan->trial_interval_unit, TRUE) : NULL,
      'signup_url' => recurly_url('subscribe', [
        'entity_type' => $entity_type,
        'entity' => $entity,
        'plan_code' => $plan_code,
        'currency' => $currency,
      ]),
      'change_url' => $current_subscription ? recurly_url('change_plan', [
        'entity_type' => $entity_type,
        'entity' => $entity,
        'subscription' => $current_subscription,
        'plan_code' => $plan_code,
      ]) : NULL,
      'selected' => FALSE,
    ];

    // If we have a pending subscription, make that its shown as selected rather
    // than the current active subscription. This should allow users to switch
    // back to a previous plan after making a pending switch to another one.
    foreach ($subscriptions as $subscription) {
      if (!empty($subscription->pending_subscription)) {
        if ($subscription->pending_subscription->plan->plan_code === $plan_code) {
          $variables['filtered_plans'][$plan_code]['selected'] = TRUE;
        }
      }
      elseif ($subscription->plan->plan_code === $plan_code) {
        $variables['filtered_plans'][$plan_code]['selected'] = TRUE;
      }
    }
  }

  // Check if this is an account that is creating a new subscription.
  $variables['expired_subscriptions'] = FALSE;
  $account = recurly_account_load(['entity_type' => $entity_type, 'entity_id' => $entity->id()]);
  if ($account) {
    $variables['expired_subscriptions'] = empty($subscriptions);
  }
}

/**
 * Implements hook_preprocess_recurly_subscription_cancel_confirm().
 */
function template_preprocess_recurly_subscription_cancel_confirm(&$variables) {
  $variables['subscription'] = $variables['form']['#subscription'];
  parse_str($this->getRequest()->getQueryString(), $query_array);
  $variables['past_due'] = isset($query_array['past_due']) && $query_array['past_due'] === '1';
}

/**
 * Implements hook_preprocess_recurly_invoice_list().
 */
function template_preprocess_recurly_invoice_list(&$variables) {
  $invoices = $variables['invoices'];
  $entity_type = $variables['entity_type'];
  $entity = $variables['entity'];

  $header = [t('Number'), t('Date'), t('Total')];
  $rows = [];
  foreach ($invoices as $invoice) {
    $status = '';
    if ($invoice->state === 'past_due') {
      $status = ' (' . t('Past due') . ')';
    }
    elseif ($invoice->state === 'failed') {
      $status = ' (' . t('Failed') . ')';
    }

    $row = [];
    $row[] = Link::createFromRoute($invoice->invoice_number . $status, 'recurly.subscription_invoice', [
      'entity' => $entity->id(),
      'invoice_number' => $invoice->invoice_number,
    ]);

    $row[] = recurly_format_date($invoice->created_at);
    $row[] = recurly_format_currency($invoice->total_in_cents, $invoice->currency);
    $rows[] = [
      'data' => $row,
      'class' => [SafeMarkup::checkPlain($invoice->state)],
    ];
  }

  $variables['table'] = [
    '#theme' => 'table',
    '#header' => $header,
    '#rows' => $rows,
    '#attributes' => ['class' => ['invoice-list']],
    '#sticky' => FALSE,
  ];
}

/**
 * Implements hook_preprocess_recurly_invoice().
 */
function template_preprocess_recurly_invoice(&$variables) {
  $invoice = $variables['invoice'];
  $invoice_account = $variables['invoice_account'];
  $entity = $variables['entity'];
  $billing_info = isset($invoice->billing_info) ? $invoice->billing_info->get() : NULL;

  $due_amount = $invoice->state !== 'collected' ? $invoice->total_in_cents : 0;
  $paid_amount = $invoice->state === 'collected' ? $invoice->total_in_cents : 0;
  $variables += [
    'invoice_date' => recurly_format_date($invoice->created_at),
    'pdf_link' => Link::createFromRoute(t('View PDF'), 'recurly.subscription_invoice_pdf', [
      'entity' => $entity->id(),
      'invoice_number' => $invoice->invoice_number,
    ]),
    'subtotal' => recurly_format_currency($invoice->subtotal_in_cents, $invoice->currency),
    'total' => recurly_format_currency($invoice->total_in_cents, $invoice->currency),
    'due' => recurly_format_currency($due_amount, $invoice->currency),
    'paid' => recurly_format_currency($paid_amount, $invoice->currency),
    'billing_info' => isset($billing_info),
    'line_items' => [],
    'transactions' => [],
  ];
  if ($billing_info) {
    $variables += [
      'first_name' => SafeMarkup::checkPlain($billing_info->first_name),
      'last_name' => SafeMarkup::checkPlain($billing_info->last_name),
      'address1' => SafeMarkup::checkPlain($billing_info->address1),
      'address2' => isset($billing_info->address2) ? SafeMarkup::checkPlain($billing_info->address2) : NULL,
      'city' => SafeMarkup::checkPlain($billing_info->city),
      'state' => SafeMarkup::checkPlain($billing_info->state),
      'zip' => SafeMarkup::checkPlain($billing_info->zip),
      'country' => SafeMarkup::checkPlain($billing_info->country),
    ];
  }
  foreach ($invoice->line_items as $line_item) {
    $variables['line_items'][$line_item->uuid] = [
      'start_date' => recurly_format_date($line_item->start_date),
      'end_date' => recurly_format_date($line_item->end_date),
      'description' => SafeMarkup::checkPlain($line_item->description),
      'amount' => recurly_format_currency($line_item->total_in_cents, $line_item->currency),
    ];
  }
  $transaction_total = 0;
  foreach ($invoice->transactions as $transaction) {
    $variables['transactions'][$transaction->uuid] = [
      'date' => recurly_format_date($transaction->created_at),
      'description' => recurly_format_transaction_status($transaction->status),
      'amount' => recurly_format_currency($transaction->amount_in_cents, $transaction->currency),
    ];
    if ($transaction->status == 'success') {
      $transaction_total += $transaction->amount_in_cents;
    }
    else {
      $variables['transactions'][$transaction->uuid]['amount'] = '(' . $variables['transactions'][$transaction->uuid]['amount'] . ')';
    }
  }
  $variables['transactions_total'] = recurly_format_currency($transaction_total, $invoice->currency);
}
